
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>17 - 预测模型入门 &#8212; 因果推断：献给求真敢为者</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=f281be69"></script>
    <script src="_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '17-Predictive-Models-101';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="16 - 断点回归设计" href="16-Regression-Discontinuity-Design.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="intro.html">
  
  
  
  
  
  
    <p class="title logo__title">因果推断：献给求真敢为者</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="intro.html">
                    因果推断：献给求真敢为者
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">第一部分 - 阳</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="01-Introduction-To-Causality.html">01 - 因果性导论</a></li>
<li class="toctree-l1"><a class="reference internal" href="02-Randomised-Experiments.html">02 - 随机实验</a></li>
<li class="toctree-l1"><a class="reference internal" href="03-Stats-Review-The-Most-Dangerous-Equation.html">03 - 统计回顾：最危险的方程</a></li>
<li class="toctree-l1"><a class="reference internal" href="04-Graphical-Causal-Models.html">04 - 图形因果模型</a></li>
<li class="toctree-l1"><a class="reference internal" href="05-The-Unreasonable-Effectiveness-of-Linear-Regression.html">05 - 线性回归的惊人有效性</a></li>
<li class="toctree-l1"><a class="reference internal" href="06-Grouped-and-Dummy-Regression.html">06 - 分组与虚拟变量回归</a></li>
<li class="toctree-l1"><a class="reference internal" href="07-Beyond-Confounders.html">07 - 超越混杂因素</a></li>
<li class="toctree-l1"><a class="reference internal" href="08-Instrumental-Variables.html">08 - 工具变量</a></li>
<li class="toctree-l1"><a class="reference internal" href="09-Non-Compliance-and-LATE.html">09 - 不依从性与局部平均处理效应</a></li>
<li class="toctree-l1"><a class="reference internal" href="10-Matching.html">10 - 匹配法</a></li>
<li class="toctree-l1"><a class="reference internal" href="11-Propensity-Score.html">11 - 倾向得分</a></li>
<li class="toctree-l1"><a class="reference internal" href="12-Doubly-Robust-Estimation.html">12 - 双重稳健估计</a></li>
<li class="toctree-l1"><a class="reference internal" href="13-Difference-in-Differences.html">13 - 双重差分法</a></li>
<li class="toctree-l1"><a class="reference internal" href="14-Panel-Data-and-Fixed-Effects.html">14 - 面板数据与固定效应</a></li>
<li class="toctree-l1"><a class="reference internal" href="15-Synthetic-Control.html">15 - 合成控制法</a></li>
<li class="toctree-l1"><a class="reference internal" href="16-Regression-Discontinuity-Design.html">16 - 断点回归设计</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">第二部分 - 阴</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 current active"><a class="current reference internal" href="#">17 - 预测模型入门</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/executablebooks/jupyter-book" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/executablebooks/jupyter-book/issues/new?title=Issue%20on%20page%20%2F17-Predictive-Models-101.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/17-Predictive-Models-101.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>17 - 预测模型入门</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">机器学习在行业中的应用</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">机器学习速成课</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">交叉验证</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">预测与决策规则</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">单一特征策略</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">将机器学习模型用于决策输入</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">更精细化的策略</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">核心要点</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">参考说明</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">参与贡献</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="id1">
<h1>17 - 预测模型入门<a class="headerlink" href="#id1" title="Link to this heading">#</a></h1>
<p>我们即将结束本书的第一部分。该部分涵盖了因果推断的核心内容，所涉及的技术广为人知且久经考验，经受住了时间的检验。第一部分为我们奠定了坚实的理论基础。用更专业的术语来说，第一部分着重定义了什么是因果推断，探讨了阻碍相关性转化为因果性的各种偏误，介绍了调整这些偏误的多种方法（回归分析、匹配法和倾向得分），以及经典的识别策略（工具变量法、双重差分法和断点回归设计）。简而言之，第一部分聚焦于我们用于识别平均处理效应 <span class="math notranslate nohighlight">\(E[Y_1 - Y_0]\)</span> 的标准技术。</p>
<p>随着我们进入第二部分，内容将变得稍显不稳定。本部分将介绍因果推断文献中的最新进展、其与机器学习的关系，以及在产业界的实际应用。在这一过程中，我们在一定程度上以可操作性和经验主义为导向，适当放宽了对学术严谨性的要求。第二部分中介绍的一些方法尚缺乏坚实的理论支持，无法清晰解释其为何有效；然而，在实际应用中，它们往往展现出良好的效果。从这个角度来看，第二部分或许对希望在日常工作中运用因果推断的行业实践者更为有益，而非专注于探索世界中根本性因果关系的学术研究者。</p>
<p>第二部分的前几章将重点探讨异质性处理效应的估计。我们将从仅关注平均处理效应 <span class="math notranslate nohighlight">\(E[Y_1 - Y_0]\)</span> 的世界，转向探究不同个体对处理如何产生差异化反应 <span class="math notranslate nohighlight">\(E[Y_1 - Y_0 | X]\)</span> 的领域。在这个世界里，个性化至关重要。我们希望优先干预那些处理效应最显著的个体，同时避免对那些可能因干预而受到负面影响的人施加处理。从某种意义上说，我们也正在从一个关于“平均处理效应是多少”的实证性问题，转向一个规范性问题：“我们应当对谁进行处理？”</p>
<p>这正是大多数企业面临的核心问题，尽管表述略有差异：应当向哪些客户提供折扣？贷款应设定何种利率？该向此用户推荐什么商品？每位顾客应展示怎样的页面布局？这些均属于处理效应异质性问题，我们可通过第二部分介绍的工具予以解答。但在深入探讨之前，有必要先阐明机器学习对产业界的意义——这将成为后续因果推断的基础工具。</p>
<section id="id2">
<h2>机器学习在行业中的应用<a class="headerlink" href="#id2" title="Link to this heading">#</a></h2>
<p>本章重点探讨<strong>机器学习</strong>在工业领域的常规应用方式。若您对机器学习尚不熟悉，可将本章视为机器学习速成课程。若从未接触过机器学习，我强烈建议您至少掌握基础知识，以便充分理解后续内容。但这并不意味着已有机器学习基础的读者应跳过本章，我仍认为通读本章将有所裨益。与其他机器学习资料不同，本章<strong>不会</strong>深入讨论决策树或神经网络等算法的细节，而是精准聚焦于<strong>机器学习在现实世界中的应用实践</strong>。</p>
<p><img alt="img" src="_images/ml-meme.png" /></p>
<p>首先，我想探讨的是为何我们要在一本因果推断的书中讨论机器学习？简而言之，是因为我认为理解因果关系的最佳方式之一，就是将其与机器学习带来的预测模型方法进行对比。长话短说，原因有二。其一，如果你已经读到本书此处，很可能对机器学习已有所了解。其二，即便你不熟悉，鉴于这些话题当前的热度，你可能也已对其有所耳闻。唯一的问题是，在机器学习被炒得沸沸扬扬的当下，我或许有必要让你回归现实，用非常实际的术语解释它究竟能做什么。最后，因果推断领域的最新进展大量运用了机器学习算法，这也是一个不容忽视的因素。</p>
<p>直截了当地说，机器学习是一种实现快速、自动且高质量预测的方法。这虽不涵盖其全部内涵，但可以说覆盖了其中约 90% 的核心内容。诸如计算机视觉、自动驾驶、语言翻译以及疾病诊断等诸多重要进展，主要都源自监督式机器学习领域。乍看之下，这些应用似乎并不像是“预测”任务。比如，语言翻译怎么会是一种预测呢？这正是机器学习的巧妙之处：我们可以将许多看似无关的问题转化为预测问题加以解决。以语言翻译为例，它可以被表述为一个预测问题：向模型输入一句话，模型需要“预测”出这句话在另一种语言中的等价表达。需要注意的是，这里所说的“预测”并不等同于传统意义上“预测未来”或“预见趋势”的概念。我们所指的预测，是指从一个明确的输入映射到一个起初未知但同样定义明确且可观测的输出。</p>
<p><img alt="img" src="_images/translation.png" /></p>
<p>机器学习真正做的事情，是学习一个输入到输出之间的映射函数——即便这个函数极其复杂。本质上，只要你能将一个问题表述为“输入到输出”的映射问题，那么机器学习就可能是一个合适的解决方案。以自动驾驶汽车为例，它并不是一个单一的预测问题，而是多个高度复杂的预测问题的集合：例如，从车辆前方传感器预测方向盘的转角、从车载摄像头预测刹车的力度、从 GPS 数据预测油门的压力。能够解决这些（以及更多）预测问题，正是实现自动驾驶的关键。</p>
<p>从更技术的角度来看，机器学习可以被理解为对期望函数（即使是非常复杂的函数）进行估计的过程：</p>
<p><span class="math notranslate nohighlight">\(
E[Y|X]
\)</span></p>
<p>其中 <span class="math notranslate nohighlight">\(Y\)</span> 代表你想获取的信息（翻译后的句子、诊断结果），而 <span class="math notranslate nohighlight">\(X\)</span> 则是已知条件（输入语句、X 光图像）。机器学习本质上就是估计该条件期望函数的一种方法。</p>
<p>好吧……现在你已经理解了，预测的力量可能远比我们最初设想的更强大。自动驾驶汽车和语言翻译固然令人兴奋，但除非你在 Google 或 Uber 这样的大型科技公司工作，这些场景通常距离我们的日常工作较远。为了使问题更贴近现实，我们不妨聚焦于几乎每家公司都会面临的一个问题：客户获取（即如何获得新客户）。</p>
<p>从客户获取的角度看，我们通常需要解决的核心问题是：如何识别那些真正有价值的客户。在这一问题中，每位客户都会带来一笔获取成本（如市场营销费用、注册引导成本、物流配送成本等），而我们希望客户在未来能为公司带来正向的现金流。举个例子，假设你是一家互联网服务提供商或燃气公司，你的典型客户可能会呈现出如下的现金流结构。</p>
<p><img alt="img" src="_images/cashflow-1.png" /></p>
<p>图中的每一个柱形代表了你与客户关系中的一个财务事件（monetary event）。例如，在获得客户的初期阶段，你需要进行市场营销投入。接着，当某人决定与你达成交易时，你可能还需要承担一定的引导成本（例如向客户说明产品如何使用）或安装成本。直到这些前期投入之后，客户才开始逐月为你带来收入。在某个时间点，客户可能需要售后支持，这会产生一定的维护费用。最后，如果客户决定终止合同，你还可能需要承担一些终止相关的额外成本。</p>
<p>为了评估某位客户是否带来了利润，我们可以将这些柱形图重排，形成一个所谓的“瀑布图（cascade plot）”。理想情况下，这些现金流事件的累计值应该显著高于零线，从而表明该客户总体上是盈利的。</p>
<p><img alt="img" src="_images/cascade-1.png" /></p>
<p>相反，也完全可能出现另一种情况：客户所带来的成本远高于其带来的收入。如果客户对你的产品使用频率很低，却频繁提出高维护需求，那么当我们将这些现金流事件加总起来时，最终的结果可能落在零线以下，意味着该客户整体上是亏损的。</p>
<p><img alt="img" src="_images/cascade-2.png" /></p>
<p>当然，这样的现金流结构可以更简单，也可能复杂得多，具体取决于你的业务类型。你甚至可以引入贴现率对未来现金流进行时间折现，把问题做得非常精细——但在这里，我们的重点已经很清楚了。</p>
<p>那么，我们能对此做些什么呢？如果你手头有大量盈利客户和非盈利客户的历史数据，你就可以训练一个机器学习模型来识别它们。通过这种方式，你可以将营销策略集中于那些更有可能带来利润的客户。或者，在合同允许的情况下，你也可以在客户产生更多成本之前选择终止合作关系。从本质上看，<strong>你正在将一个商业决策问题表述为一个预测问题，以便用机器学习方法求解</strong>：你希望预测或识别出哪些客户是盈利的，哪些是亏损的，从而只与前者建立联系。</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn</span><span class="w"> </span><span class="kn">import</span> <span class="n">ensemble</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.model_selection</span><span class="w"> </span><span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.pipeline</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.metrics</span><span class="w"> </span><span class="kn">import</span> <span class="n">r2_score</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">seaborn</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sns</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">style</span>
<span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s2">&quot;ggplot&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</details>
</div>
<p>举个例子，假设你掌握了 10,000 名客户在过去 30 天内的交易数据，并且知道每位客户的获取成本 <code class="docutils literal notranslate"><span class="pre">cacq</span></code> 。这个获取成本可以是你在在线广告投放中为他们出价的金额，也可以是物流运输费用，或是你为帮助客户使用产品所进行的培训成本。</p>
<p>此外，为了简化问题（毕竟这是速成课，不是一学期的客户价值评估课程），我们暂且假设你对是否与客户建立合作拥有完全决策权。换句话说，即便客户想与你达成交易，你也可以选择拒绝。</p>
<p>在这种设定下，你的任务就是<strong>提前识别哪些客户将会带来利润</strong>，从而只选择与这些客户建立业务关系。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">transactions</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s2">&quot;data/customer_transactions.csv&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">transactions</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">transactions</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(10000, 32)
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>customer_id</th>
      <th>cacq</th>
      <th>day_0</th>
      <th>day_1</th>
      <th>day_2</th>
      <th>day_3</th>
      <th>day_4</th>
      <th>day_5</th>
      <th>day_6</th>
      <th>day_7</th>
      <th>...</th>
      <th>day_20</th>
      <th>day_21</th>
      <th>day_22</th>
      <th>day_23</th>
      <th>day_24</th>
      <th>day_25</th>
      <th>day_26</th>
      <th>day_27</th>
      <th>day_28</th>
      <th>day_29</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>-110</td>
      <td>6</td>
      <td>0</td>
      <td>73</td>
      <td>10</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>21</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>-58</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>15</td>
      <td>0</td>
      <td>3</td>
      <td>2</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>-7</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>-30</td>
      <td>0</td>
      <td>3</td>
      <td>2</td>
      <td>0</td>
      <td>9</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>40</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4</td>
      <td>-42</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 32 columns</p>
</div></div></div>
</div>
<p>现在我们需要做的，是根据这些交易数据将“好客户”和“坏客户”区分开来。为了简化问题，我们将所有交易金额与获取成本（CACQ）做总和处理。需要注意的是，这种做法掩盖了许多细节——比如，无法区分已经流失的客户和那些仅仅在两次购买之间暂时中断的客户。</p>
<p>接下来，我将这个总和定义为一个变量，称为 <code class="docutils literal notranslate"><span class="pre">net\_value</span></code>，并将其与客户的特征数据进行合并。由于我们的目标是在客户尚未转化之前预测其是否会带来利润，因此我们<strong>只能使用获取之前可观察到的数据</strong>。在本例中，这些特征包括年龄、所在地区和收入水平，保存在另一个 <code class="docutils literal notranslate"><span class="pre">CSV</span></code> 文件中。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">profitable</span> <span class="o">=</span> <span class="p">(</span><span class="n">transactions</span><span class="p">[[</span><span class="s2">&quot;customer_id&quot;</span><span class="p">]]</span>
              <span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">net_value</span> <span class="o">=</span> <span class="n">transactions</span>
                      <span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s2">&quot;customer_id&quot;</span><span class="p">)</span>
                      <span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>

<span class="n">customer_features</span> <span class="o">=</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s2">&quot;data/customer_features.csv&quot;</span><span class="p">)</span>
                     <span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">profitable</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;customer_id&quot;</span><span class="p">))</span>

<span class="n">customer_features</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>customer_id</th>
      <th>region</th>
      <th>income</th>
      <th>age</th>
      <th>net_value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>30</td>
      <td>1025</td>
      <td>24</td>
      <td>130</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>41</td>
      <td>1649</td>
      <td>26</td>
      <td>10</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>18</td>
      <td>2034</td>
      <td>33</td>
      <td>-6</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>20</td>
      <td>1859</td>
      <td>35</td>
      <td>136</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4</td>
      <td>1</td>
      <td>1243</td>
      <td>26</td>
      <td>-8</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>很好！我们的任务正变得越来越具体：我们希望识别出那些 <strong>净收益为正（<code class="docutils literal notranslate"><span class="pre">net_value</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>）</strong> 的盈利客户，并将其与不盈利客户区分开来。接下来我们会尝试不同的方法，看看哪种效果更好。但在此之前，我们需要快速了解一下机器学习的基本原理（如果你已经了解机器学习的工作机制，也可以跳过本节）。</p>
</section>
<section id="id3">
<h2>机器学习速成课<a class="headerlink" href="#id3" title="Link to this heading">#</a></h2>
<p>就我们的目标而言，可以将机器学习理解为一种功能强大、适用于预测任务的工具。为了让机器学习发挥作用，你需要一组带有“标签”（也称为“真实值”）的数据。接着，你可以用这些已知标签的数据来训练机器学习模型，并将训练好的模型应用于那些标签未知的样本上，进行预测。</p>
<p>下图展示了机器学习的一般工作流程：</p>
<p><img alt="img" src="_images/ml-flow.png" /></p>
<p>首先，你需要一组观测值，其中的“真实值”（此处指 <code class="docutils literal notranslate"><span class="pre">net_value</span></code>）是已知的。接着，你可以利用这组数据来<strong>估计</strong>一个机器学习模型，使其通过特征变量（在本例中为地区、收入和年龄）预测 <code class="docutils literal notranslate"><span class="pre">net_value</span></code>。这一估计过程将产出一个预测函数，该函数可用于在尚未观测到 <code class="docutils literal notranslate"><span class="pre">net_value</span></code> 的情况下，对新样本进行预测。</p>
<p>在图像左侧所示的流程中，我们手中拥有一批新客户的特征数据（地区、收入、年龄），但尚未获得其 <code class="docutils literal notranslate"><span class="pre">net_value</span></code>。将这些变量输入先前估计的模型后，模型便会输出相应的 <code class="docutils literal notranslate"><span class="pre">net_value</span></code> 预测值。</p>
<p>如果你更倾向于技术性表述，机器学习的目标可以理解为<strong>估计条件期望函数</strong> <span class="math notranslate nohighlight">\(E[Y \mid X]\)</span>，其中 <span class="math notranslate nohighlight">\(Y\)</span> 是因变量（也称为结果变量），<span class="math notranslate nohighlight">\(X\)</span> 是特征变量。机器学习提供了一种强大的手段来构造 <span class="math notranslate nohighlight">\(\hat{E}[Y \mid X]\)</span> 的估计，通常是通过最小化某种损失函数（loss function）或预测误差实现的。</p>
<p>需要注意的是，机器学习模型具有极强的灵活性，能够逼近几乎任意形式的函数。换句话说，模型可以强大到<strong>对训练样本实现完全拟合</strong>。因此，机器学习方法通常包含<strong>复杂度超参数</strong>（complexity hyperparameters），用于控制模型的灵活性与拟合程度。</p>
<p>如下图所示，左图展示了一个低复杂度的模型（拟合不足），中图为适中复杂度模型，右图则为高复杂度模型，可见其几乎对训练数据实现了完全拟合。</p>
<p><img alt="img" src="_images/model-fit.png" /></p>
<p>这就引出了一个问题：<strong>在将模型应用于真实世界之前，我们如何判断它是否有效？</strong>
一个常用的方法是：将模型的预测结果与我们已知真实值的数据进行比较。这类比较所用的指标被称为<strong>拟合优度指标</strong>（goodness-of-fit metrics），例如 <span class="math notranslate nohighlight">\(R^2\)</span>。</p>
<p>但请记住，模型可以变得足够复杂，以至于完全拟合训练数据。在这种情况下，预测值与真实值会完全吻合。然而，这种“完美拟合”是有问题的，因为它会使验证结果产生误导——模型之所以表现优异，仅仅是因为它足够复杂，而不是因为它具备良好的泛化能力。</p>
<p>此外，通常来说，<strong>过于复杂的模型并不是好事</strong>。你可能已经对这点有了直觉。回顾上图中的模型选择：你更倾向于哪个模型？是那个准确拟合所有数据点的复杂模型？大概不是。你可能更倾向于中间那个模型——它更加平滑、结构更简单，同时仍然具备良好的预测能力，即使不能完全拟合所有数据点。</p>
<p><img alt="img" src="_images/overfitting.jpg" /></p>
<p>你的直觉是正确的。如果一个模型过于复杂，它不仅会学习到数据中的系统性结构，还会“学习”到其中的随机噪声。但在真实世界中，噪声是变化的（毕竟它是随机的），所以你那个“完美”拟合训练集的模型在实际预测时往往会出现错误。在机器学习术语中，这种现象称为<strong>过拟合（overfitting）</strong>，即模型在训练集表现良好，但泛化能力较差。</p>
<p>那我们该怎么办？</p>
<p>一个常见的做法是：我们假装无法访问部分数据。具体做法是：将原始数据集（即我们拥有真实值的数据）划分为两个子集，一部分用于模型训练，另一部分用于验证预测效果。这种方法称为<strong>交叉验证（cross-validation）</strong>。</p>
<p><img alt="img" src="_images/test.png" /></p>
<p>如下图所示，在那部分模型从未见过的数据中，复杂模型的表现并不好；反而是中间复杂度的模型，预测效果更为稳健。为了选择合适的模型复杂度，我们可以估计多个不同复杂度的模型，并比较它们在未参与训练的数据上的预测表现。</p>
<p><strong>交叉验证的重要性不容忽视，值得我们花更多时间深入理解。</strong></p>
</section>
<section id="id4">
<h2>交叉验证<a class="headerlink" href="#id4" title="Link to this heading">#</a></h2>
<p>交叉验证（cross validation）在选择模型复杂度时非常重要，但它的用途远不止于此。事实上，只要我们希望在模型实际应用前尝试多种方案，并评估它们在现实中的表现，都可以使用交叉验证。</p>
<p>交叉验证的基本思想是模拟现实场景：我们在已有数据上估计模型，但模型真正应用时，是在新的、未曾见过的数据上进行预测。保留一部分数据不用于训练，可以作为未来真实数据的近似，用于评估模型的泛化能力。</p>
<p>我们来看一下，如何将交叉验证应用到识别盈利客户的问题中。大致流程如下：</p>
<ol class="arabic simple">
<li><p>我们有一部分现有客户的数据，并知道哪些客户是盈利的、哪些不是（即我们有真实值）。我们称这部分为训练集（training set）。</p></li>
<li><p>利用训练集，我们学习一个规则，用于判断客户是否盈利。</p></li>
<li><p>然后，将这一规则应用于训练过程中未使用的另一部分数据（测试集），这模拟了在一个数据集上构建规则并将其应用于另一个数据集的过程。在模型投入实际使用后，这种情况是不可避免的。</p></li>
</ol>
<p>下图展示了交叉验证的基本流程：最右侧是真正未观测的数据，中间部分是我们在训练阶段假装“不可见”的数据。</p>
<p><img alt="img" src="_images/cross-validation.png" /></p>
<p>总结来说，我们会将内部数据划分为训练集和测试集。训练集用于构建判断客户是否盈利的模型，测试集用于验证模型的预测效果。这部分测试数据在训练过程中是不可用的，从而更好地评估模型的泛化性能。</p>
<p>顺便提一句，除了简单的训练-测试划分外，现实中还有很多更精细的交叉验证方式，例如 K 折交叉验证（k-fold cross-validation）或时间交叉验证（temporal cross-validation）。不过在这里，这种简单划分已经足够使用。</p>
<p>交叉验证的核心目的是模拟模型投入实际使用后的表现。通过这种方式，我们可以获得更接近现实的预测效果评估。</p>
<p>在本例中，我们采用最简单的方式：将数据划分为两部分，70% 用于训练模型识别盈利客户，30% 用于评估该模型的预测能力。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">train</span><span class="p">,</span> <span class="n">test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">customer_features</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>
<span class="n">train</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">test</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>((7000, 5), (3000, 5))
</pre></div>
</div>
</div>
</div>
</section>
<section id="id5">
<h2>预测与决策规则<a class="headerlink" href="#id5" title="Link to this heading">#</a></h2>
<p><img alt="img" src="_images/profit.png" /></p>
<p>前面我们一直在讨论识别盈利客户的方法与思路，现在是时候更精准地定义几个关键概念了。我们将引入两个术语：<strong>预测（prediction）<strong>和</strong>策略（policy）</strong>。</p>
<p>首先，预测是一个用来估计某个结果的数值，对应的是 <span class="math notranslate nohighlight">\(\hat{E}[y_i \mid X_i]\)</span>，即条件期望的估计值。例如，我们可以预测某个客户的预期盈利为 16 巴西雷亚尔（BRL），意思是我们预计该客户将为公司带来 16 BRL 的净收益。这里的重点在于：预测只是一个数值。</p>
<p>第二个概念是策略（policy），即一种自动化的决策规则。预测给出的是一个数，而策略对应的是一个决策。例如，我们可以设定这样一个策略：当客户收入高于 1000 时与其建立合作，低于则不合作。更常见的是，我们基于预测值来制定策略：例如，预测盈利大于 10 的客户我们选择合作，否则不合作，也即 <span class="math notranslate nohighlight">\(\hat{E}[y_i \mid X_i] &gt; 10\)</span>。</p>
<p>通常来说，机器学习负责的是第一步，也就是产生预测值。但需要注意的是，仅有预测本身是不够的，我们必须将其与相应的决策规则（策略）结合起来，才能在实际中发挥作用。</p>
<p>我们既可以采用非常简单的模型与策略，也可以设计复杂的预测与决策系统。不论复杂与否，对于预测与策略，我们都必须使用交叉验证：在一部分数据上估计预测值或策略，并在另一部分数据上验证其效果。</p>
<p>由于我们已经将数据划分为训练集和测试集，现在可以开始进行模型构建与策略评估了。</p>
</section>
<section id="id6">
<h2>单一特征策略<a class="headerlink" href="#id6" title="Link to this heading">#</a></h2>
<p>在我们用机器学习“火力全开”解决盈利性客户识别问题之前，不妨先从最简单的策略入手。也就是所谓的“用 20% 的努力获得 80% 的收益”的方法。这类方法常常效果显著，令人惊讶的是，许多数据科学家反而忽略了它们。</p>
<p>那么，最简单的策略是什么？很自然地，就是：与所有客户建立合作关系。与其花大量精力判断哪些客户是盈利的，不如干脆对所有客户一视同仁，期望盈利客户所带来的收益足以覆盖非盈利客户的损失。</p>
<p>要判断这个策略是否可行，我们可以计算所有客户的平均净值（average net value）。如果这个平均值为正，说明从整体上看，与客户合作是盈利的。尽管个体客户中会存在盈利与非盈利之分，但只要客户数量足够多，总体上我们是赚钱的。</p>
<p>相反，如果这个平均净值为负，就意味着如果与所有客户合作，我们总体上将会亏损。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">train</span><span class="p">[</span><span class="s2">&quot;net_value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-29.169428571428572
</pre></div>
</div>
</div>
</div>
<p>这就有些让人失望了……如果我们与所有客户都建立合作关系，每位客户将平均带来约 30 雷亚尔的亏损。我们尝试的第一个、非常简单的策略失败了。如果不想让业务亏损，我们最好寻找一些更有希望的方法。</p>
<p>这里顺便插一句，别忘了这是一个教学示例。虽然“与所有人都合作”这种简单策略在这个例子中不奏效，但在现实中，它们常常是有效的。比如：向所有用户群发营销邮件通常比什么都不做要好，向所有客户发放优惠券往往比不发更有效。</p>
<p>那么，接下来我们能想到的最简单策略是什么？一个自然的思路是：<strong>直接利用已有的特征变量，看它们是否能够区分盈利客户与非盈利客户</strong>。比如说“收入”（<code class="docutils literal notranslate"><span class="pre">income</span></code>）这个变量——直觉上来说，收入越高的客户应该越有可能带来盈利，对吧？如果我们只与收入最高的一部分客户合作，会不会是个好主意？</p>
<p>要验证这个想法，我们可以将客户按照收入划分为若干分位组（quantiles）。分位组的好处在于，它可以将数据划分为大小相等的子组，因此具有很好的比较性。接着，我们可以对每个收入分位组计算其平均净值。</p>
<p>我们的期望是，尽管总体平均净值为负（即 <span class="math notranslate nohighlight">\(E[\text{NetValue}] &lt; 0\)</span>），但在某些由收入定义的子群体中，可能存在净值为正的情况，即 <span class="math notranslate nohighlight">\(E[\text{NetValue} \mid \text{Income}=x] &gt; 0\)</span>，尤其是高收入客户群体。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span><span class="c1">## seed because the CIs from seaborn uses boostrap</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>

<span class="c1"># pd.qcut create quantiles of a column</span>
<span class="n">sns</span><span class="o">.</span><span class="n">barplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">train</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">income_quantile</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">qcut</span><span class="p">(</span><span class="n">train</span><span class="p">[</span><span class="s2">&quot;income&quot;</span><span class="p">],</span> <span class="n">q</span><span class="o">=</span><span class="mi">20</span><span class="p">)),</span> 
            <span class="n">x</span><span class="o">=</span><span class="s2">&quot;income_quantile&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;net_value&quot;</span><span class="p">,</span>
            <span class="n">hue</span><span class="o">=</span><span class="s2">&quot;income_quantile&quot;</span><span class="p">,</span> <span class="n">palette</span><span class="o">=</span><span class="s2">&quot;husl&quot;</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Profitability by Income&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">70</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/cc85ebce25bcab2e9a9f97fa17351607d1f81891e3d2c75161dfe39abe642bfe.png" src="_images/cc85ebce25bcab2e9a9f97fa17351607d1f81891e3d2c75161dfe39abe642bfe.png" />
</div>
</div>
<p>但遗憾的是，结果依然不理想。无论收入水平如何，所有分位组的客户其平均净值仍为负值。尽管高收入客户“没那么差”，即其平均亏损相对较小，但总体而言，他们仍然是亏损客户。因此，收入变量在这里并未帮到我们太多。</p>
<p>那我们不妨看看其他变量，比如地区（region）。如果我们的大部分成本来源于为偏远地区的客户提供服务，那么我们就可以合理地假设：<strong>地区变量可能有助于区分盈利客户与非盈利客户</strong>。</p>
<p>由于“地区”本身就是一个类别变量，我们不需要像收入那样进行分位处理。我们可以直接查看各地区的平均净值，看看是否存在某些地区客户更可能盈利。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>

<span class="n">region_plot</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">barplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">train</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s2">&quot;region&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;net_value&quot;</span><span class="p">,</span> 
    <span class="n">hue</span><span class="o">=</span><span class="s2">&quot;region&quot;</span><span class="p">,</span> <span class="n">palette</span><span class="o">=</span><span class="s2">&quot;husl&quot;</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="kc">False</span>         
                         <span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Profitability by Region&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/2441620e6e421945d8e6ec4413e8fd9917767f4ea17fea09b8543c75390d5246.png" src="_images/2441620e6e421945d8e6ec4413e8fd9917767f4ea17fea09b8543c75390d5246.png" />
</div>
</div>
<p>太好了！从图中我们可以清楚地看到，一些地区是盈利的，比如地区 2、17、39；而另一些地区则是亏损的，比如地区 0、9、29，尤其是表现特别差的地区 26。这个结果非常有希望！我们可以据此制定一个简单的策略：只与数据显示为盈利的地区客户开展业务。</p>
<p>值得注意的是，我们现在所做的事情，其实本质上就是机器学习模型所做的，只不过方式更为简单——我们正在估计每个地区的条件期望值，即：</p>
<div class="math notranslate nohighlight">
\[
E[\text{NetValue} \mid \text{Region}]
\]</div>
<p>接下来，我们需要基于这个估计结果构造一个策略。我们将采用一个非常简单的方法：为每个地区的平均净值构造一个 95% 的置信区间。如果该置信区间的下限大于 0，我们就认为该地区的客户是盈利的，并选择与之开展业务。</p>
<p>下面的代码构造了一个字典，其中键是地区编号，值是该地区净值期望的 95% 置信区间的下限。然后，我们筛选出所有下限大于零的地区。这些地区即为我们根据当前数据决定开展业务的地区。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># extract the lower bound of the 95% CI from the plot above</span>
<span class="n">regions_to_net</span> <span class="o">=</span> <span class="n">train</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;region&#39;</span><span class="p">)[</span><span class="s1">&#39;net_value&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">agg</span><span class="p">([</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;count&#39;</span><span class="p">,</span> <span class="s1">&#39;std&#39;</span><span class="p">])</span>

<span class="n">regions_to_net</span> <span class="o">=</span> <span class="n">regions_to_net</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span>
    <span class="n">lower_bound</span><span class="o">=</span><span class="n">regions_to_net</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.96</span><span class="o">*</span><span class="n">regions_to_net</span><span class="p">[</span><span class="s1">&#39;std&#39;</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">regions_to_net</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
<span class="p">)</span>

<span class="n">regions_to_net_lower_bound</span> <span class="o">=</span> <span class="n">regions_to_net</span><span class="p">[</span><span class="s1">&#39;lower_bound&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
<span class="n">regions_to_net</span> <span class="o">=</span> <span class="n">regions_to_net</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>

<span class="c1"># filters regions where the net value lower bound is &gt; 0.</span>
<span class="n">regions_to_invest</span> <span class="o">=</span> <span class="p">{</span><span class="n">region</span><span class="p">:</span> <span class="n">net</span> 
                     <span class="k">for</span> <span class="n">region</span><span class="p">,</span> <span class="n">net</span> <span class="ow">in</span> <span class="n">regions_to_net_lower_bound</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                     <span class="k">if</span> <span class="n">net</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">}</span>

<span class="n">regions_to_invest</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{1: 2.9729729729729737,
 2: 20.543302704837856,
 4: 10.051075065003388,
 9: 32.08862469914759,
 11: 37.434210420891255,
 12: 37.44213667009524,
 15: 32.09847683044394,
 17: 39.52753893574483,
 18: 41.86162250217046,
 19: 15.62406327716401,
 20: 22.06654814414531,
 21: 24.621030401718578,
 25: 33.97022928360584,
 35: 11.68776141117673,
 37: 27.83183541449011,
 38: 49.740709395699994,
 45: 2.286387928016998,
 49: 17.018537095350286}
</pre></div>
</div>
</div>
</div>
<p>变量 <code class="docutils literal notranslate"><span class="pre">regions_to_invest</span></code> 包含了我们决定要开展业务的所有地区。接下来，我们来看一下这个策略在测试集上的表现——也就是我们“假装没有见过”的那部分数据。</p>
<p>这一步是评估策略效果的关键。原因在于：某个地区在训练集中看起来是盈利的，可能仅仅是由于样本波动或偶然性。如果这种盈利表现只是随机出现的，那么我们很可能无法在测试集中观察到相同的规律。</p>
<p>为此，我们会将测试集中仅属于这些被判断为“盈利”的地区的客户筛选出来，然后绘制这些客户的净收益分布图，并计算我们策略对应的平均净收益。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">region_policy</span> <span class="o">=</span> <span class="p">(</span><span class="n">test</span><span class="p">[</span><span class="n">test</span><span class="p">[</span><span class="s2">&quot;region&quot;</span><span class="p">]</span>
                      <span class="c1"># filter regions in regions_to_invest</span>
                      <span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">regions_to_invest</span><span class="o">.</span><span class="n">keys</span><span class="p">())])</span> 

<span class="n">sns</span><span class="o">.</span><span class="n">histplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">region_policy</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s2">&quot;net_value&quot;</span><span class="p">)</span>
<span class="c1"># average has to be over all customers, not just the one we&#39;ve filtered with the policy</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Average Net Income: </span><span class="si">%.2f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">region_policy</span><span class="p">[</span><span class="s2">&quot;net_value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">test</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/96a5e21537c57794dade7708912fd69a0e6bdcd4fa5e2987b33cd03a601fe6be.png" src="_images/96a5e21537c57794dade7708912fd69a0e6bdcd4fa5e2987b33cd03a601fe6be.png" />
</div>
</div>
</section>
<section id="id7">
<h2>将机器学习模型用于决策输入<a class="headerlink" href="#id7" title="Link to this heading">#</a></h2>
<p>如果你希望进一步提升策略效果，现在我们可以借助机器学习的强大能力。当然，需要注意的是，这通常会显著增加建模复杂度，而实际提升可能只是边际上的。但在某些情况下，边际提升也可能转化为可观的收益，这正是机器学习在现实中广受重视的原因之一。</p>
<p>在这里，我们将使用一种名为梯度提升（Gradient Boosting）的模型。这类模型从原理上来说相对复杂，但使用起来其实非常方便。就我们的目的而言，并不需要深入其内部机制，只需要回忆在“机器学习速成课”中学到的内容：机器学习模型本质上是一个强大的预测工具，用于估计条件期望 <span class="math notranslate nohighlight">\(E[Y \mid X]\)</span>。模型越复杂，其拟合能力越强，但如果复杂度过高，就可能发生过拟合，学习到噪声，导致在新数据上表现不佳。因此，我们仍需使用交叉验证，确保模型复杂度合适。</p>
<p>那么，问题来了：<strong>我们该如何利用这些更好的预测结果来改进我们之前基于地区的简单策略，从而更有效地识别并接触盈利客户？</strong></p>
<p>我认为这里有两个主要的改进点。第一，逐个变量地寻找能够区分盈利客户和非盈利客户的特征，其实是一个非常繁琐的过程。在本例中，我们只有三个变量（年龄、收入和地区），工作量还不算大，但如果有上百个变量，显然就难以操作。此外，这样做还容易引发<a class="reference external" href="https://en.wikipedia.org/wiki/Multiple_comparisons_problem">多重检验（multiple testing）</a>问题和假阳性率偏高的问题。</p>
<p>第二点是，客户的盈利能力往往不是由单一变量决定的。在我们的例子中，除了地区变量以外，收入和年龄也可能包含关于客户价值的重要信息。虽然我们先前发现收入单独预测效果不强，但如果只在“略微亏损”的那些地区中考虑高收入客户，或许仍有可能实现盈利。换句话说，我们是在提出一个更强的预测结构：</p>
<div class="math notranslate nohighlight">
\[
E[\text{NetValue} \mid \text{Region}, \text{Income}, \text{Age}] &gt; E[\text{NetValue} \mid \text{Region}]
\]</div>
<p>这个思路是合理的：在已有的地区基础上，加入收入和年龄的信息，应该可以提高我们对客户净值的预测精度。</p>
<p>然而，构造这样更复杂的策略，尤其是涉及多个变量交互关系的策略，其组合数量将呈指数增长，很难手动完成。更可行的方式是：将所有特征变量输入机器学习模型，让模型自动学习这些变量之间的关系和交互项。这正是我们接下来要做的事情。</p>
<p>我们的目标是建立一个预测 <code class="docutils literal notranslate"><span class="pre">net_value</span></code> 的模型，使用的特征包括 <code class="docutils literal notranslate"><span class="pre">region</span></code>、<code class="docutils literal notranslate"><span class="pre">income</span></code> 和 <code class="docutils literal notranslate"><span class="pre">age</span></code>。其中，“地区”是一个类别变量，我们需要先将其转换为数值型。这里我们采用的方法是：将每个地区替换为它在训练集中的平均净值。还记得我们之前构造的 <code class="docutils literal notranslate"><span class="pre">regions_to_net</span></code> 字典吗？只需用 <code class="docutils literal notranslate"><span class="pre">.replace()</span></code> 方法将该字典传入即可。</p>
<p>由于我们将多次进行这种替换操作，接下来会将其封装成一个函数。这个过程属于机器学习中常说的<strong>特征工程（feature engineering）</strong>，也就是为了帮助模型学习而对原始变量进行转换与处理。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">encode</span><span class="p">(</span><span class="n">df</span><span class="p">):</span> 
    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">replace</span><span class="p">({</span><span class="s2">&quot;region&quot;</span><span class="p">:</span> <span class="n">regions_to_net</span><span class="p">})</span>
</pre></div>
</div>
</div>
</div>
<p>接下来，我们将从 <a class="reference external" href="https://scikit-learn.org/stable/">Sklearn</a> 导入模型。Sklearn 中的所有模型都有非常标准的使用流程：</p>
<p>首先，需要实例化模型，并传入一些用于控制模型复杂度的参数。对于这个梯度提升模型，我们将设置估计器数量为 400，最大深度为 4，等等。一般来说，模型越深、估计器数量越多，模型的拟合能力就越强。当然，我们不能让模型过于强大，否则它可能会学习到训练数据中的噪声，即发生过拟合。</p>
<p>不过，你无需了解这些参数的具体含义，只要记住：这是一个预测性能很强的模型就足够了。</p>
<p>然后，要训练模型，只需调用 <code class="docutils literal notranslate"><span class="pre">.fit()</span></code> 方法，并将特征变量 <code class="docutils literal notranslate"><span class="pre">X</span></code> 和我们想要预测的因变量（即目标变量）<code class="docutils literal notranslate"><span class="pre">net_value</span></code> 作为输入即可。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">model_params</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;n_estimators&#39;</span><span class="p">:</span> <span class="mi">400</span><span class="p">,</span>
                <span class="s1">&#39;max_depth&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
                <span class="s1">&#39;min_samples_split&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
                <span class="s1">&#39;learning_rate&#39;</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">,</span>
                <span class="s1">&#39;loss&#39;</span><span class="p">:</span> <span class="s1">&#39;squared_error&#39;</span><span class="p">}</span>

<span class="n">features</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;region&quot;</span><span class="p">,</span> <span class="s2">&quot;income&quot;</span><span class="p">,</span> <span class="s2">&quot;age&quot;</span><span class="p">]</span>
<span class="n">target</span> <span class="o">=</span> <span class="s2">&quot;net_value&quot;</span>

<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>

<span class="n">reg</span> <span class="o">=</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">GradientBoostingRegressor</span><span class="p">(</span><span class="o">**</span><span class="n">model_params</span><span class="p">)</span>

<span class="c1"># fit model on the training set</span>
<span class="n">encoded_train</span> <span class="o">=</span> <span class="n">train</span><span class="p">[</span><span class="n">features</span><span class="p">]</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">encode</span><span class="p">)</span>
<span class="n">reg</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">encoded_train</span><span class="p">,</span> <span class="n">train</span><span class="p">[</span><span class="n">target</span><span class="p">]);</span>
</pre></div>
</div>
</div>
</div>
<p>模型现在已经训练完成，接下来我们需要评估它的效果。为此，我们要查看该模型<strong>在测试集上的预测表现</strong>。</p>
<p>用于评估机器学习模型预测性能的指标有很多种。这里我们采用其中一个常用指标：<span class="math notranslate nohighlight">\(R^2\)</span>（决定系数）。我们不需要深入讨论其技术细节，简单理解即可：
<span class="math notranslate nohighlight">\(R^2\)</span> 通常用于评估对连续变量的预测模型，比如 <code class="docutils literal notranslate"><span class="pre">net_value</span></code>。</p>
<p>值得注意的是，<span class="math notranslate nohighlight">\(R^2\)</span> 的取值范围可以从负无穷到 1。如果模型的预测效果甚至比直接用平均值还差，<span class="math notranslate nohighlight">\(R^2\)</span> 就会为负值；如果模型能够完美预测，则 <span class="math notranslate nohighlight">\(R^2 = 1\)</span>。</p>
<p>从直观上说，<span class="math notranslate nohighlight">\(R^2\)</span> 表示模型能够解释 <code class="docutils literal notranslate"><span class="pre">net_value</span></code> 变异程度的比例。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">train_pred</span> <span class="o">=</span> <span class="p">(</span><span class="n">encoded_train</span>
              <span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">predictions</span><span class="o">=</span><span class="n">reg</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">encoded_train</span><span class="p">[</span><span class="n">features</span><span class="p">])))</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Train R2: &quot;</span><span class="p">,</span> <span class="n">r2_score</span><span class="p">(</span><span class="n">y_true</span><span class="o">=</span><span class="n">train</span><span class="p">[</span><span class="n">target</span><span class="p">],</span> <span class="n">y_pred</span><span class="o">=</span><span class="n">train_pred</span><span class="p">[</span><span class="s2">&quot;predictions&quot;</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Test R2: &quot;</span><span class="p">,</span> <span class="n">r2_score</span><span class="p">(</span><span class="n">y_true</span><span class="o">=</span><span class="n">test</span><span class="p">[</span><span class="n">target</span><span class="p">],</span> <span class="n">y_pred</span><span class="o">=</span><span class="n">reg</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">test</span><span class="p">[</span><span class="n">features</span><span class="p">]</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">encode</span><span class="p">))))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Train R2:  0.7108790300152951
Test R2:  0.6938513063048141
</pre></div>
</div>
</div>
</div>
<p>在本例中，模型解释了训练集中约 71% 的 <code class="docutils literal notranslate"><span class="pre">net_value</span></code> 方差，而在测试集中只能解释约 69%。这是可以预期的：由于模型在训练时接触过训练集数据，其在该数据集上的表现往往会被高估。</p>
<p>顺带一提，如果你想更深入了解<strong>过拟合（overfitting）</strong>，可以尝试将模型的 <code class="docutils literal notranslate"><span class="pre">max_depth</span></code> 参数设为 14，然后观察结果。你很可能会发现训练集上的 <span class="math notranslate nohighlight">\(R^2\)</span> 飙升，而测试集上的 <span class="math notranslate nohighlight">\(R^2\)</span> 反而下降——这正是过拟合的典型表现。</p>
<p>接下来，为了制定我们的策略，我们将把模型在测试集上的预测结果存储在一个名为 <code class="docutils literal notranslate"><span class="pre">prediction</span></code> 的新列中。这个预测值即为条件期望的估计：</p>
<div class="math notranslate nohighlight">
\[
\hat{E}[\text{NetValue} \mid \text{Age}, \text{Income}, \text{Region}]
\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">model_policy</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">prediction</span><span class="o">=</span><span class="n">reg</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">test</span><span class="p">[</span><span class="n">features</span><span class="p">]</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">encode</span><span class="p">)))</span>

<span class="n">model_policy</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>customer_id</th>
      <th>region</th>
      <th>income</th>
      <th>age</th>
      <th>net_value</th>
      <th>prediction</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>5952</th>
      <td>5952</td>
      <td>19</td>
      <td>1983</td>
      <td>23</td>
      <td>21</td>
      <td>47.734883</td>
    </tr>
    <tr>
      <th>1783</th>
      <td>1783</td>
      <td>31</td>
      <td>914</td>
      <td>31</td>
      <td>-46</td>
      <td>-36.026935</td>
    </tr>
    <tr>
      <th>4811</th>
      <td>4811</td>
      <td>33</td>
      <td>1349</td>
      <td>25</td>
      <td>-19</td>
      <td>22.553420</td>
    </tr>
    <tr>
      <th>145</th>
      <td>145</td>
      <td>20</td>
      <td>1840</td>
      <td>26</td>
      <td>55</td>
      <td>48.306256</td>
    </tr>
    <tr>
      <th>7146</th>
      <td>7146</td>
      <td>19</td>
      <td>3032</td>
      <td>34</td>
      <td>-17</td>
      <td>7.039414</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>就像我们之前对 <code class="docutils literal notranslate"><span class="pre">region</span></code> 变量所做的那样，我们也可以根据模型的预测值来查看平均净值的分布。但由于模型预测结果是连续变量而不是类别变量，我们需要先将其<strong>离散化</strong>。</p>
<p>一种常用的做法是使用 pandas 中的 <code class="docutils literal notranslate"><span class="pre">pd.qcut</span></code> 函数（说实话，我非常喜欢这个函数！）。它可以根据模型的预测值将数据按分位数进行分组。</p>
<p>我们这里使用 50 个分位组，主要是因为我们之前的 <code class="docutils literal notranslate"><span class="pre">region</span></code> 变量正好也有 50 个取值。作为一种惯例，我倾向于将这些由模型预测值分组得到的分位组称为<strong>模型带（model bands）</strong>，这个称呼更直观地反映了：每个分组内的预测值落在某一个区间范围内，比如从 -10 到 200。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>

<span class="n">n_bands</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">bands</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;band_</span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n_bands</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>

<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
<span class="n">model_plot</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">barplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">model_policy</span>
                         <span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">model_band</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">qcut</span><span class="p">(</span><span class="n">model_policy</span><span class="p">[</span><span class="s2">&quot;prediction&quot;</span><span class="p">],</span> <span class="n">q</span><span class="o">=</span><span class="n">n_bands</span><span class="p">)),</span>
                         <span class="n">x</span><span class="o">=</span><span class="s2">&quot;model_band&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;net_value&quot;</span><span class="p">,</span>
                         <span class="n">hue</span><span class="o">=</span><span class="s2">&quot;model_band&quot;</span><span class="p">,</span> <span class="n">palette</span><span class="o">=</span><span class="s2">&quot;husl&quot;</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="kc">False</span>  
                        <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Profitability by Model Prediction Quantiles&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">70</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/35b66a19dadc964bbf82724726ff86aa06b5c2b9eb85a4e62a37363030efe9cc.png" src="_images/35b66a19dadc964bbf82724726ff86aa06b5c2b9eb85a4e62a37363030efe9cc.png" />
</div>
</div>
<p>我们可以观察到，有些模型带的净值非常为负，而另一些则非常为正；还有一些模型带的净值则处于不确定状态——我们无法明确判断其为正还是为负。</p>
<p>此外，值得注意的是，从左到右，净值呈现出上升趋势。这是符合预期的：既然我们是在预测净值，那么预测值越高，实际净值也应该相应更高，二者应具有一定的正相关关系。</p>
<p>现在，为了将基于机器学习模型的策略与我们之前仅使用地区变量的策略进行比较，我们可以绘制净收益的直方图，并同时展示测试集上的总净收益。</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">model_plot_df</span> <span class="o">=</span> <span class="p">(</span><span class="n">model_policy</span><span class="p">[</span><span class="n">model_policy</span><span class="p">[</span><span class="s2">&quot;prediction&quot;</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>
<span class="n">sns</span><span class="o">.</span><span class="n">histplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">model_plot_df</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s2">&quot;net_value&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;C2&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;model_policy&quot;</span><span class="p">)</span>

<span class="n">region_plot_df</span> <span class="o">=</span> <span class="p">(</span><span class="n">model_policy</span><span class="p">[</span><span class="n">model_policy</span><span class="p">[</span><span class="s2">&quot;region&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">regions_to_invest</span><span class="o">.</span><span class="n">keys</span><span class="p">())])</span>
<span class="n">sns</span><span class="o">.</span><span class="n">histplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">region_plot_df</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s2">&quot;net_value&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;region_policy&quot;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Model Net Income: </span><span class="si">%.2f</span><span class="s2">;    Region Policy Net Income </span><span class="si">%.2f</span><span class="s2">.&quot;</span> <span class="o">%</span> 
          <span class="p">(</span><span class="n">model_plot_df</span><span class="p">[</span><span class="s2">&quot;net_value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">test</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
           <span class="n">region_plot_df</span><span class="p">[</span><span class="s2">&quot;net_value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">test</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">();</span>
</pre></div>
</div>
</div>
</details>
<div class="cell_output docutils container">
<img alt="_images/9ef111f5902db8ec40dd5e97d83d75dd80b2f70264acd2bd0a4ef2a82bdbc5a7.png" src="_images/9ef111f5902db8ec40dd5e97d83d75dd80b2f70264acd2bd0a4ef2a82bdbc5a7.png" />
</div>
</div>
<p>正如我们所看到的，机器学习模型确实构建出了一个比仅使用 <code class="docutils literal notranslate"><span class="pre">region</span></code> 特征更优的策略，但提升幅度不大。在测试集中，模型策略为每位客户带来的平均净收益约为 16.6 雷亚尔，而基于地区的策略仅为 15.5 雷亚尔。虽然差距不大，但如果客户数量非常庞大，这种边际提升已经足以证明使用机器学习模型的合理性。</p>
</section>
<section id="id8">
<h2>更精细化的策略<a class="headerlink" href="#id8" title="Link to this heading">#</a></h2>
<p>回顾一下，我们目前为止测试了几种策略：</p>
<ol class="arabic">
<li><p>最简单的策略是与所有客户合作，这相当于估计边际净收益：</p>
<div class="math notranslate nohighlight">
\[
   \hat{E}[\text{NetValue}] &gt; 0
   \]</div>
<p>由于这种策略的平均每客户净收益为负，因此效果不佳。</p>
</li>
<li><p>接着我们尝试了一个基于单一特征的策略，即基于地区信息做决策：只在特定地区开展业务，对应形式为：</p>
<div class="math notranslate nohighlight">
\[
   \hat{E}[\text{NetValue} \mid \text{Region}] &gt; 0
   \]</div>
<p>这一策略带来了显著改进。</p>
</li>
<li><p>然后我们引入机器学习，使用所有特征变量建立预测模型，对应表达为：</p>
<div class="math notranslate nohighlight">
\[
   \hat{E}[\text{NetValue} \mid \text{Region}, \text{Income}, \text{Age}] &gt; 0
   \]</div>
<p>基于这个模型，我们制定了策略：只与预测净值为正的客户开展合作。</p>
</li>
</ol>
<p>上述所有策略的决策逻辑都是二元的：是否与客户建立合作关系。这类策略通常可以表达为如下形式：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">prediction</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">do</span> <span class="n">business</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">don</span><span class="err">’</span><span class="n">t</span> <span class="n">do</span> <span class="n">business</span>
</pre></div>
</div>
<p>这种策略被称为<strong>阈值策略（thresholding）</strong>：当预测值超过某个阈值（在本例中是 0）时采取某一行动，否则采取另一行动。</p>
<p>阈值策略在很多实际场景中都适用，尤其当决策是二元选择时非常有效。例如在交易欺诈识别中，如果欺诈模型的预测得分高于某个阈值 X，则拒绝交易，否则批准。</p>
<p>然而，在某些情况下，决策可能并不是简单的“做”或“不做”，而是程度型或连续型决策。例如，你可能愿意对预计特别盈利的客户投入更多营销预算，甚至将他们加入“重点客户名单”，给予额外服务（虽然这也意味着更高的服务成本）。</p>
<p>一旦考虑这种情况，决策就从<strong>二元选择</strong>转向<strong>连续选择</strong>：你不只是决定是否与客户合作，还要决定在每位客户身上投入多少资源。</p>
<p>下面这个示例中，假设你的决策不再是“是否合作”，而是“对每位客户应投入多少营销预算”。再进一步，假设你正与其他公司竞争——谁在某位客户身上花的营销费最多，谁就赢得该客户（类似于竞价机制）。那么，合理的策略是：<strong>对高盈利客户投入多、对边际盈利客户投入少、对亏损客户不投入</strong>。</p>
<p>实现该策略的一种方式是：将预测值离散化为分组（band）。我们之前已经使用过类似的方法来对预测结果进行可视化，但这次我们将它用于实际决策。</p>
<p>我们将把预测结果划分为 20 个分组，可以理解为 20 个分位组或等大小的客户群。第 1 组将包含预测净值最低的 5% 客户，第 2 组包含第 5% 到第 10% 的客户……而第 20 组则包含预测净值最高的客户。</p>
<p>请注意：分组边界必须基于训练集来确定，然后才能将其应用于测试集。因此，我们会使用 <code class="docutils literal notranslate"><span class="pre">pd.qcut</span></code> 在训练集上计算出这些分组边界（bins），接着用 <code class="docutils literal notranslate"><span class="pre">np.digitize</span></code> 将测试集中的预测值分配到对应的分组中。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">model_binner</span><span class="p">(</span><span class="n">prediction_column</span><span class="p">,</span> <span class="n">bins</span><span class="p">):</span>
    <span class="c1"># find the bins according to the training set</span>
    <span class="n">bands</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">qcut</span><span class="p">(</span><span class="n">prediction_column</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="n">retbins</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">binner_function</span><span class="p">(</span><span class="n">prediction_column</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">prediction_column</span><span class="p">,</span> <span class="n">bands</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">binner_function</span>
    

<span class="c1"># train the binning function</span>
<span class="n">binner_fn</span> <span class="o">=</span> <span class="n">model_binner</span><span class="p">(</span><span class="n">train_pred</span><span class="p">[</span><span class="s2">&quot;predictions&quot;</span><span class="p">],</span> <span class="mi">20</span><span class="p">)</span>

<span class="c1"># apply the binning</span>
<span class="n">model_band</span> <span class="o">=</span> <span class="n">model_policy</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">bands</span> <span class="o">=</span> <span class="n">binner_fn</span><span class="p">(</span><span class="n">model_policy</span><span class="p">[</span><span class="s2">&quot;prediction&quot;</span><span class="p">]))</span>
<span class="n">model_band</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>customer_id</th>
      <th>region</th>
      <th>income</th>
      <th>age</th>
      <th>net_value</th>
      <th>prediction</th>
      <th>bands</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>5952</th>
      <td>5952</td>
      <td>19</td>
      <td>1983</td>
      <td>23</td>
      <td>21</td>
      <td>47.734883</td>
      <td>18</td>
    </tr>
    <tr>
      <th>1783</th>
      <td>1783</td>
      <td>31</td>
      <td>914</td>
      <td>31</td>
      <td>-46</td>
      <td>-36.026935</td>
      <td>7</td>
    </tr>
    <tr>
      <th>4811</th>
      <td>4811</td>
      <td>33</td>
      <td>1349</td>
      <td>25</td>
      <td>-19</td>
      <td>22.553420</td>
      <td>15</td>
    </tr>
    <tr>
      <th>145</th>
      <td>145</td>
      <td>20</td>
      <td>1840</td>
      <td>26</td>
      <td>55</td>
      <td>48.306256</td>
      <td>18</td>
    </tr>
    <tr>
      <th>7146</th>
      <td>7146</td>
      <td>19</td>
      <td>3032</td>
      <td>34</td>
      <td>-17</td>
      <td>7.039414</td>
      <td>13</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">sns</span><span class="o">.</span><span class="n">barplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">model_band</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s2">&quot;bands&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;net_value&quot;</span><span class="p">,</span> <span class="n">hue</span><span class="o">=</span><span class="s2">&quot;bands&quot;</span><span class="p">,</span> <span class="n">palette</span><span class="o">=</span><span class="s2">&quot;husl&quot;</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Model Bands&quot;</span><span class="p">);</span>
</pre></div>
</div>
</div>
</details>
<div class="cell_output docutils container">
<img alt="_images/46d645eea455c1fb052f7322a6b19ab44154320cc5908b395244f297059f76d1.png" src="_images/46d645eea455c1fb052f7322a6b19ab44154320cc5908b395244f297059f76d1.png" />
</div>
</div>
<p>有了这些分组（bands），我们就可以将大部分的营销预算集中投放在第 19 和第 20 组客户身上。请注意，我们的决策模式已经从最初的<strong>二元选择（是否合作）</strong>，演变为一个<strong>连续决策问题</strong>：即<strong>对每位客户应投入多少营销资源</strong>。</p>
<p>当然，你可以通过增加分组数量进一步细化策略；在极限情况下，甚至可以<strong>不再进行分组</strong>，而是<strong>直接使用模型的预测值作为投资决策的依据</strong>。比如：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mkt_investments_i</span> <span class="o">=</span> <span class="n">model_prediction_i</span> <span class="o">*</span> <span class="mf">0.3</span>
</pre></div>
</div>
<p>也就是说，对于每位客户 <span class="math notranslate nohighlight">\(i\)</span>，我们按照模型预测的净值投入其中 30% 的营销预算（这里的 30% 只是一个示意性的参数，具体数值可以根据实际情况调整）。</p>
</section>
<section id="id9">
<h2>核心要点<a class="headerlink" href="#id9" title="Link to this heading">#</a></h2>
<p>在非常短的时间内，我们已经覆盖了大量内容，因此这一总结非常有必要，帮助我们理清目前的进展。</p>
<p>首先，我们学习了机器学习的大多数应用，其核心只是围绕一个目标：做出高质量的预测。所谓预测，可以理解为：从一个已知的输入变量，映射到一个起初未知但定义明确的输出变量。这种预测本质上就是估计条件期望函数 <span class="math notranslate nohighlight">\(E[Y \mid X]\)</span>。</p>
<p>当然，说“仅仅是做预测”可能并不完全公平。我们也看到了，良好的预测能够帮助我们解决许多超出直觉的问题，例如语言翻译、自动驾驶等。</p>
<p>随后，我们回到更贴近现实的商业应用场景，探讨了如何通过预测客户的盈利能力，制定谁值得我们投入资源、谁不值得的策略。具体而言，我们尝试预测客户净收益，并基于该预测值建立相应的策略。这只是预测模型的一个应用示例，类似的还有信用评分、欺诈检测、癌症诊断等领域——只要预测有用，机器学习就能发挥作用。</p>
<p>本章的核心结论是：</p>
<blockquote>
<div><p><strong>只要你能将一个业务问题表述为一个预测问题，那么机器学习很可能就是解决它的最佳工具。</strong></p>
</div></blockquote>
<p>我必须特别强调这一点。在当前机器学习被大量炒作的背景下，人们常常忽略了这一基本原则，反而投入大量精力构建一些预测能力很强、但对实际业务无用的模型。</p>
<p>正确的顺序应当是：<strong>先思考如何将业务问题转化为预测问题，然后再用机器学习工具去解决它</strong>。而不是反过来：先构建一个预测模型，再去寻找有没有哪个业务问题能“凑合用”这个模型。后一种方式偶尔可能奏效，但更多时候只是“盲目试错”，最终变成“为了解决模型而找问题”的局面。</p>
</section>
<section id="id10">
<h2>参考说明<a class="headerlink" href="#id10" title="Link to this heading">#</a></h2>
<p>本章内容大多是我个人的经验总结，很多观点和方法来自于我的实务体会。因此，我无法为这些内容提供严格意义上的学术参考文献。这也意味着，这些内容尚未经过系统性的学术审查，不像正规科研工作那样经过同行评议与理论论证。你也许会注意到，我在这里主要谈论的是“在实践中有效的方法”*，而没有花太多篇幅去解释其背后的理论基础。这可以被看作是一种“来自一线的经验科学”（a sort of science from the streets）。不过，既然我将这部分内容公开发布，自然也欢迎所有人的批评与反馈——如果你发现其中有明显错误或不妥之处，非常欢迎你提交 issue，我会尽我所能给予回应。</p>
<p>最后，我也意识到，对于那些希望系统学习机器学习的读者来说，我在本章的讲解可能过于简略了。坦率地说，我认为自己真正能够贡献价值的领域，是因果推断的教学，而非机器学习。后者已经有大量优质的公开资源，远远超过我所能提供的内容。其中的经典之作，就是 <a class="reference external" href="https://www.coursera.org/learn/machine-learning">Andrew Ng 的机器学习课程</a>，如果你是机器学习初学者，我强烈推荐你去认真学习这门课程。</p>
</section>
<section id="id11">
<h2>参与贡献<a class="headerlink" href="#id11" title="Link to this heading">#</a></h2>
<p><strong>《Causal Inference for the Brave and True》</strong> 是一本关于因果推断的开源教材，致力于以经济上可负担、认知上可理解的方式，普及这门“科学的统计基础”。全书基于 Python，仅使用自由开源软件编写，原始英文版本由 <a class="reference external" href="https://github.com/matheusfacure">Matheus Facure</a> 编写与维护。</p>
<p>本书的中文版由黄文喆与许文立教授合作翻译，并托管在 <a class="reference external" href="https://github.com/Wenzhe-Huang/python-causality-handbook-zh">GitHub 中文主页</a>。希望本地化的内容能帮助更多中文读者学习和掌握因果推断方法。</p>
<p>如果你觉得这本书对你有帮助，并希望支持该项目，可以前往 <a class="reference external" href="https://www.patreon.com/causal_inference_for_the_brave_and_true">Patreon</a> 支持原作者。</p>
<p>如果你暂时不方便进行经济支持，也可以通过以下方式参与贡献：</p>
<ul class="simple">
<li><p>修正错别字</p></li>
<li><p>提出翻译或表达建议</p></li>
<li><p>反馈你未能理解的部分内容</p></li>
</ul>
<p>欢迎前往英文版或中文版仓库点击 <a class="reference external" href="https://github.com/matheusfacure/python-causality-handbook/issues">issues 区</a> 或 <a class="reference external" href="https://github.com/Wenzhe-Huang/python-causality-handbook-zh/issues">中文版 issues 区</a> 提出反馈。</p>
<p>最后，如果你喜欢这本书的内容，也请将其分享给可能感兴趣的朋友，并为项目在 GitHub 上点亮一颗星：<a class="reference external" href="https://github.com/matheusfacure/python-causality-handbook">英文版仓库</a> / <a class="reference external" href="https://github.com/Wenzhe-Huang/python-causality-handbook-zh">中文版仓库</a>。</p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="16-Regression-Discontinuity-Design.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">16 - 断点回归设计</p>
      </div>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">机器学习在行业中的应用</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">机器学习速成课</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">交叉验证</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">预测与决策规则</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">单一特征策略</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">将机器学习模型用于决策输入</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">更精细化的策略</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">核心要点</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">参考说明</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">参与贡献</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Matheus Facure
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>